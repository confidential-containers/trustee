# Attestation Policy (Developing)

CoCo AS provides a flexible policy support based on Rego to facilitate the customized verification rules.

The policy will be enforced to generate an attestation token, i.e. EAR token.

EAR tokens support an expressive policy result.
A valid policy must evaluate at least one of the following claims as an integer between 127 and -127.
* `instance_identity`
* `configuration`
* `executables`
* `file_system`
* `hardware`
* `runtime_opaque`
* `storage_opaque`
* `sourced_data`

These dimensions can be used to return a detailed, but generic description of the TCB of the attester.
More information about these trust claims, including what the numerical values of the claims represent,
can be found [here](https://datatracker.ietf.org/doc/draft-ietf-rats-ar4si/).

A policy can also optionally define a claim called `extensions`.
Any extensions that are specified via this claim will be added to the attestation token.
The extensions claim should contain an array of extension objects.
An extension object should look like this:
```json
{
    "name": "<name-of-extension>",
    "key": "<index-of-extension>",
    "value": ...
}
```

Extension names should be Collision-Resistant Public Claim Names.
The extension key should be an i32.
If the extension is registered in the EAR specification, the key will be positive.
Otherwise, the key should be negative.
The extension value can be any valid JSON, including nested objects.

The default policy includes the extension `ear.trustee.identifiers`, which is used
to store fields that identify the workload.
With Confidential Containers these identifiers will usually be based on the Kata
Agent Policy or other configuration fields in the InitData.
Other runtimes might use other mechanisms, such as the event log.
The `identifiers` extension includes two subfields.

* `validated` identifiers are those that are bound to the hardware evidence via
attestation and that the guest runtime binds to the workload.
* `unvalidated` identifiers are anything else that describe the workload.

AS policies will be provided `input`.

`input` are the TCB claims generated by the verifier.

See the [default policy](../src/ear_token/ear_default_policy_cpu.rego) for an example.

> [!NOTE]
> We now provide a new extension in AS policy. If any field or value should be fetched from RVPS,
> we can use function `query_reference_value(key_name)` in the rego to get reference value with key
> id `key_name` from RVPS. If no key is found in RVPS, the extension will evaluate to `null`.
>
> An example of section is like
> ```
> executables := 3 if {
> 	input.tpm
> 	input.tpm.pcr11 == query_reference_value("pcr11")
> }
> ```

When using EAR tokens, the policy used to evaluate CPU evidence should end in `_cpu`.
If you upload your own policy, be sure to use this suffix.
When attesting multiple devices, a policy is required for each device class.
If you have devices of class `gpu` upload a policy with an id ending in `_gpu` i.e. `default_gpu`.

## How to Use Policy

For both [gRPC CoCo AS](../../protos/attestation.proto) and [Restful CoCo AS](./restful-as.md), we have a
parameter named `policy_ids` to specify which policies to use to enforce the evidence check.

For a running CoCoAS, we can set any new policies.

Let's give some quick guides.

### gRPC CoCo AS

Firstly, start a gRPC CoCo AS
```shell
cd attestation-service/tests/e2e
make grpc.pid
```

Then, set a new policy to the CoCo AS.
We have prepared an [example SetPolicy request](../tests/coco-as/policy/grpc-set-policy.json) with [policy](../tests/coco-as/policy/new_policy.rego) and policy id `example-policy`. The policy should be `Base64 URL SAFE NO PAD` encoded.

```shell
REQ=$(cat ../../tests/coco-as/policy/grpc-set-policy.json)
grpcurl \
  -plaintext \
  -import-path ../../protos \
  -proto ../../protos/attestation.proto \
  -d @ 127.0.0.1:50004 attestation.AttestationService/SetAttestationPolicy <<EOF
$REQ
EOF
```

Then, we can use the policy to check against an evidence. We use the [request](../tests/coco-as/policy/check.json) to do this.

```shell
REQ=$(cat ../../tests/coco-as/policy/check.json)
grpcurl \
  -plaintext \
  -import-path ../../protos \
  -proto ../../protos/attestation.proto \
  -d @ 127.0.0.1:50004 attestation.AttestationService/AttestationEvaluate <<EOF
$REQ
EOF
```

### Restful CoCo AS

Firstly, start a Restful CoCo AS
```shell
cd attestation-service/tests/e2e
make restful.pid
```

Then, set a new policy to the CoCo AS.
We have prepared an [example SetPolicy request](../tests/coco-as/policy/restful-set-policy.json) with [policy](../tests/coco-as/policy/new_policy.rego) and policy id `example-policy`. The policy should be `Base64 URL SAFE NO PAD` encoded.

```shell
curl -k -X POST http://127.0.0.1:8080/policy \
     -i \
     -H 'Content-Type: application/json' \
     -d @../../tests/coco-as/policy/restful-set-policy.json
```

Then, we can use the policy to check against an evidence. We use the [request](../tests/coco-as/policy/check.json) to do this.

```shell
curl -k -X POST http://127.0.0.1:8080/attestation \
     -i \
     -H 'Content-Type: application/json' \
     -d @../../tests/coco-as/policy/check.json
```

## How to Write a Policy (Experimental)

:warning: **Warning:** The policy feature is still under development and it might be changed flexibly before we get a stable version.

We will introduce the format of policy by providing some examples to show the use cases.

1. The [default policy](../src/ear_token/ear_default_policy_cpu.rego). This policy assigns multiple trust claims based on reference values.
2. An [SGX policy](../tests/coco-as/policy/example-1.rego). The client want to ensure the `mr_signer` and `mrenclave` are both expected value.
3. A [TDX policy](../tests/coco-as/policy/example-2.rego). The client want to ensure the TDX module (reflected by `tdx.quote.body.mr_seam`), guest firmware (reflected by `tdx.quote.body.mr_td`), tcb_status (reflected by `input.tdx.tcb_status`), collateral expiration status (reflected by `input.tdx.collateral_expiration_status`) are all as expected.
4. A [IBM SE policy](../tests/coco-as/policy/example-3.rego). The client want to ensure the `se.version`, `se.tag`, `se.user_data`, `se.image_phkh` and `se.attestation_phkh` are all expected value.
